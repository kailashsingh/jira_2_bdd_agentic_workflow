from langchain_openai import ChatOpenAI
from langchain_ollama import ChatOllama
from langchain.prompts import ChatPromptTemplate
from typing import Dict, List

import re
from src.config.settings import settings
from src.config.logging import get_logger

logger = get_logger(__name__)

class BDDGeneratorAgent:
    def __init__(self, rag_tools):
        logger.info(f'OpenAI Model Used: {settings.model_name}')
        self.llm = ChatOpenAI(
            model=settings.model_name,
            temperature=0.2,
            api_key=settings.openai_api_key,
        )
        
        self.rag_tools = rag_tools
    
    def is_testable(self, ticket: Dict) -> bool:
        """Determine if a ticket requires testing"""
        prompt = ChatPromptTemplate.from_template("""
        Analyze this Jira ticket and determine if it requires BDD testing.
        
        Ticket Details:
        Type: {issue_type}
        Summary: {summary}
        Description: {description}
        Acceptance Criteria: {acceptance_criteria}
        
        Return TRUE if this is a user story or feature that requires testing.
        Return FALSE if this is a bug fix, documentation, or infrastructure task.
        
        Answer with only TRUE or FALSE.
        """)
        
        response = self.llm.invoke(
            prompt.format_messages(**ticket)
        )
        
        return "TRUE" in response.content.upper()
    
    def generate_bdd_scenarios(self, ticket: Dict, existing_code: List[Dict], application_data: Dict = None) -> Dict:
        """Generate BDD scenarios and step definitions"""
        
        # Format existing code context
        code_context = "\n\n".join([
            f"File: {code['metadata']['path']}\n{code['content'][:500]}..."
            for code in existing_code[:3]
        ])
        
        # Format application data context
        app_context = ""
        if application_data:
            app_context = f"Application Data Collected:{app_context}"
#             app_context = f"""
# Application Data Collected:
# URL: {application_data.get('url', 'N/A')}
# Title: {application_data.get('title', 'N/A')}
# Elements Found: {len(application_data.get('elements', []))}
# Forms Found: {len(application_data.get('forms', []))}
# Navigation Flow: {', '.join(application_data.get('navigation_flow', []))}

# Key Elements:
# {chr(10).join([f"- {elem.get('type', 'unknown')}: {elem.get('text', elem.get('placeholder', 'N/A'))}" for elem in application_data.get('elements', [])[:10]])}

# Forms:
# {chr(10).join([f"- Form with {len(form.get('inputs', []))} inputs" for form in application_data.get('forms', [])[:3]])}
# """
        
        prompt = ChatPromptTemplate.from_template("""
        You are a BDD test automation expert. Generate BDD scenarios and step definitions
        for the following Jira ticket.
        
        Jira Ticket:
        Key: {key}
        Summary: {summary}
        Description: {description}
        Acceptance Criteria: {acceptance_criteria}
        
        Existing Code Context:
        {code_context}
        
        {app_context}
        
        Generate:
        1. A Gherkin feature file with comprehensive scenarios
        2. TypeScript step definitions using WebDriverIO
        
        Follow these guidelines:
        - Use existing step definitions where possible
        - Follow the coding patterns from the existing codebase
        - Include both happy path and edge cases
        - Use clear, business-readable language
        - If application data is provided, use specific element selectors and navigation flows
        - Include realistic test data based on the actual application elements found
        - Ensure the feature file and step definitions are well-structured and maintainable
        - Add a tag with the Jira ticket key and @AutoGenerated to the feature file
        - Do NOT use Markdown code blocks (```).
        - Use the exact markers <<FEATURE_START>> ... <<FEATURE_END>> and <<STEPS_START>> ... <<STEPS_END>>.
        
        Format your response as:
        FEATURE_FILE:
        <<FEATURE_START>>                                          
        [Gherkin content here]
        <<FEATURE_END>>                                          
        
        STEP_DEFINITIONS:
        <<STEPS_START>>                                          
        [TypeScript code here]
        <<STEPS_END>>
        
        ### Few-Shot Examples

        **Example 1**

        FEATURE_FILE:
        <<FEATURE_START>>
        @Jira-Ticket-Key1 @AutoGenerated                                          
        Feature: User login
        Scenario: Successful login
            Given user is on login page
            When user enters valid credentials
            Then user is redirected to homepage
        <<FEATURE_END>>

        STEP_DEFINITIONS:
        <<STEPS_START>>
        import {{ Given, When, Then }} from '@wdio/cucumber-framework';
        Given('user is on login page', async () => {{
        await browser.url('/login');
        }});
        When('user enters valid credentials', async () => {{
        await $('#username').setValue('test');
        await $('#password').setValue('pass');
        await $('button=Login').click();
        }});
        Then('user is redirected to homepage', async () => {{
        await expect(browser).toHaveUrl('/home');
        }});
        <<STEPS_END>>

        **Example 2**

        FEATURE_FILE:
        <<FEATURE_START>>
        @Jira-Ticket-Key2 @AutoGenerated
        Feature: Search product
        Scenario: Find existing item
            Given user is on homepage
            When user searches for "laptop"
            Then search results with laptops should appear
        <<FEATURE_END>>

        STEP_DEFINITIONS:
        <<STEPS_START>>
        import {{ Given, When, Then }} from '@wdio/cucumber-framework';
        Given('user is on homepage', async () => {{
        await browser.url('/');
        }});
        When('user searches for {{string}}', async (term) => {{
        await $('#search').setValue(term);
        await $('button=Search').click();
        }});
        Then('search results with laptops should appear', async () => {{
        await expect($('.result-item')).toBeExisting();
        }});
        <<STEPS_END>>                                          
        """)
        
        response = self.llm.invoke(
            prompt.format_messages(
                **ticket,
                code_context=code_context,
                app_context=app_context
            )
        )
        
        logger.info(f'BDD Generation LLM Response: {response.content[:10]}...')

        # Parse the response
        content = response.content
        logger.debug(f'Full LLM Response Content: {content}')
        feature_match = re.search(r"<<FEATURE_START>>(.*?)<<FEATURE_END>>", content, re.S)
        steps_match = re.search(r"<<STEPS_START>>(.*?)<<STEPS_END>>", content, re.S)

        logger.info(f'Feature Match: {feature_match is not None}, Steps Match: {steps_match is not None}')
        feature_content = ""
        step_def_content = ""

        if feature_match and steps_match:
            feature_content = feature_match.group(1).strip()
            step_def_content = steps_match.group(1).strip()
            logger.info(f'Extracted Feature Content: {feature_content[:10]}...')
            logger.info(f'Extracted Step Definitions Content: {step_def_content[:10]}...')
        else:
            logger.error("Failed to extract feature or step definition content")

        return {
            'feature': feature_content,
            'step_definitions': step_def_content,
            'ticket_key': ticket['key']
        }